<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ycw&#39; blogs</title>
  
  <subtitle>发型不能乱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-08T01:55:45.081Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ycw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo使用技巧</title>
    <link href="http://yoursite.com/2020/01/07/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/01/07/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-01-07T04:08:09.000Z</published>
    <updated>2020-01-08T01:55:45.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加入图片的方法"><a href="#加入图片的方法" class="headerlink" title="加入图片的方法"></a>加入图片的方法</h2><p>First<br>1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true</p><p>2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</p><p>3 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹</p><p>Second<br>4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p><p><img src="/.com//%E5%9B%BE%E7%89%87%E5%90%8D.jpg" alt="你想输入的替代文字"></p><p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p><p>5 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是<img src="/.com//02/26/xxxx/图片名.jpg">，而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;加入图片的方法&quot;&gt;&lt;a href=&quot;#加入图片的方法&quot; class=&quot;headerlink&quot; title=&quot;加入图片的方法&quot;&gt;&lt;/a&gt;加入图片的方法&lt;/h2&gt;&lt;p&gt;First&lt;br&gt;1 把主页配置文件_config.yml 里的post_asset_folder:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://yoursite.com/2020/01/07/Opreation-System/"/>
    <id>http://yoursite.com/2020/01/07/Opreation-System/</id>
    <published>2020-01-07T02:44:50.000Z</published>
    <updated>2020-01-08T01:55:42.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统学习笔记</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>指系统中的资源可以被多个并发进程同时使用。分为两种共享的方式：互斥共享和同时共享，</p><ul><li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li></ul><h3 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h3><ul><li><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p></li><li><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p></li><li><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p></li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>进程是资源分配的基本单位</li><li>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li></ul><p><img src="/.com//process.jpg" alt="进程控制模块"></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>线程是独立调度的基本单位</li><li>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</li></ul><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li>拥有资源</li></ul><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><ul><li>调度</li></ul><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><ul><li>系统开销</li></ul><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><ul><li>通信方面</li></ul><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>注意事项：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><ul><li>先来先服务  first-come first-serverd（FCFS）</li></ul><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><ul><li>短作业优先 shortest job first（SJF）</li></ul><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><ul><li>最短剩余时间优先 shortest remaining time next（SRTN）</li></ul><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待</p><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><ul><li>时间片轮转</li></ul><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。<br>而如果时间片过长，那么实时性就不能得到保证。</p><ul><li>优先级调度</li></ul><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><ul><li>多级反馈队列</li></ul><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="/.com//duilie.jpg" alt="进程控制模块"></p><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><ul><li>进程同步</li></ul><ol><li>临界区</li></ol><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><ol start="2"><li><p>同步与互斥</p><p>（1） 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。<br>（2） 互斥：多个进程在同一时刻只有一个进程能进入临界区</p><ol start="3"><li>信号量</li></ol><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><p>（1）down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；<br>（2）up: 对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</p><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p></li></ol><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用信号量实现生产者-消费者问题 </li></ul><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">end</span>;</span><br><span class="line"><span class="built_in">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">(item: integer)</span></span>;</span><br><span class="line">    <span class="built_in">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N then wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> then signal(empty);</span><br><span class="line">    <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">    function <span class="built_in">remove</span>: integer;</span><br><span class="line">    <span class="built_in">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> then wait(empty);</span><br><span class="line">        <span class="built_in">remove</span> = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N <span class="number">-1</span> then signal(full);</span><br><span class="line">    <span class="built_in">end</span>;</span><br><span class="line"><span class="built_in">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line">procedure producer</span><br><span class="line"><span class="built_in">begin</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">begin</span></span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="built_in">end</span></span><br><span class="line"><span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line">procedure consumer</span><br><span class="line"><span class="built_in">begin</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">begin</span></span><br><span class="line">        item = ProducerConsumer.<span class="built_in">remove</span>;</span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="built_in">end</span></span><br><span class="line"><span class="built_in">end</span>;</span><br></pre></td></tr></table></figure><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><ul><li>哲学家进餐问题</li></ul><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        <span class="built_in">put</span>(i);</span><br><span class="line">        <span class="built_in">put</span>((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ol><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读者-写者问题</li></ul><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;p&gt;操作系统学习笔记&lt;/p&gt;
&lt;h4 id=&quot;共享&quot;&gt;&lt;a href=&quot;#共享&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JAVA基础</title>
    <link href="http://yoursite.com/2020/01/06/JAVA-basic/"/>
    <id>http://yoursite.com/2020/01/06/JAVA-basic/</id>
    <published>2020-01-06T06:16:28.000Z</published>
    <updated>2020-01-08T01:55:45.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul><li><p>面向过程：性能高，因为类调用需要实例化。</p></li><li><p>面向对象：易维护，易复用，易扩展。</p></li><li><p>但是不是 Java 性能差的根本原因，面向过程也需要分配内存，计算内存偏移量，主要原因是 Java 是半编译语言，最终执行代码并不是可以直接被CPU执行的二进制机械码，而面向过程的语言大多是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也并不一定比 Java 好。</p></li></ul><h3 id="JVM-JDK-和-JRE"><a href="#JVM-JDK-和-JRE" class="headerlink" title="JVM JDK 和 JRE"></a>JVM JDK 和 JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机是运行在Java字节码的虚拟机，VM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><h4 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h4><p>JVM 可以理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Java 程序从源代码</p><img src="https://camo.githubusercontent.com/8f6eceddf64b5948c69a398d1a0e777c9c7f8e5b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67"><p>  <strong>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言.</strong></p><p><strong>HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</strong></p><h4 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h4><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><h3 id="Java基本类型"><a href="#Java基本类型" class="headerlink" title="Java基本类型"></a>Java基本类型</h3><ul><li><p>byte/8</p></li><li><p>char/16</p></li><li><p>short/16</p></li><li><p>int/32</p></li><li><p>float/32</p></li><li><p>long/64</p></li><li><p>double/64</p></li><li><p>boolean/~</p><p>  boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p></li></ul><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><ul><li><p>基本类型有默认值，而包装类型初始为null。</p></li><li><p>在Java中，一切皆对象，但八大基本类型却不是对象。</p></li><li><p>声明方式的不同，基本类型无需通过new关键字来创建，而封装类型需new关键字。 </p></li><li><p>存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。</p></li><li></li></ul><p>基本类型都有对应的包装类型，基本类型相互对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数 x =  <span class="number">2</span> ;     <span class="comment">//装箱调用了Integer.valueOf（2）</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">//拆箱调用了X.intValue（）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java基础知识
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2020/01/06/Network/"/>
    <id>http://yoursite.com/2020/01/06/Network/</id>
    <published>2020-01-06T06:12:02.000Z</published>
    <updated>2020-01-06T06:31:28.717Z</updated>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
    
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>tmall_springboot</title>
    <link href="http://yoursite.com/2019/12/24/tmall-springboot/"/>
    <id>http://yoursite.com/2019/12/24/tmall-springboot/</id>
    <published>2019-12-24T01:10:08.000Z</published>
    <updated>2019-12-26T01:42:20.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="spring-boot实现天猫前端和后台管理"><a href="#spring-boot实现天猫前端和后台管理" class="headerlink" title="spring boot实现天猫前端和后台管理"></a>spring boot实现天猫前端和后台管理</h3><hr><h4 id="选用技术"><a href="#选用技术" class="headerlink" title="选用技术"></a>选用技术</h4><ol><li>Java</li><li>前端：html, CSS, Javascript, JSON, AJAX, JQuery ,Bootstrap, Vue.js </li><li>框架：spring springMVC spring boot</li><li>中间件： redis,nginx,elasticsearch,shiro</li><li>数据库：MySQL</li><li>开发工具：idea,maven</li></ol><hr><h4 id="需求分析-前台"><a href="#需求分析-前台" class="headerlink" title="需求分析-前台"></a>需求分析-前台</h4><ol><li><p>首页<br>（1）在横向导航栏上提供4个分类连接<br>（2）在纵向导航栏上提供全部17个分类连接<br>（3）当鼠标移动到某一个纵向分类连接的时候，显示这个分类下的推荐商品<br>（4）按照每种分类显示5个商品的方式，显示所有17种分类    </p></li><li><p>分类页<br>（1）显示分辨率为950x100的当前分类图片<br>（2）显示本分类下的所有产品    </p></li><li><p>查询结果页<br>显示满足查询条件的商品</p></li><li><p>产品页<br>（1）显示分辨率为950x100的当前商品对应的分类图片<br>（2）显示本商品的5个单独图片<br>（3）商品的基本信息，如标题，小标题，价格，销量，评价数量，库存等<br>（4）商品详情<br>（5）评价信息<br>（6）5张商品详细图片</p></li><li><p>结算页面<br>在结算页面显示被选中的订单项</p></li><li><p>支付页面<br>确认支付页面显示本次订单的金额总数</p></li><li><p>支付成功页面<br>付款成功时，显示本次付款金额</p></li><li><p>购物车页面<br>在购物车中显示订单项</p></li><li><p>我的订单页面<br>显示所有订单，以及对应的订单项</p></li><li><p>确认收货页面<br>（1）显示订单项内容<br>（2）显示订单信息，收货人地址等    </p></li><li><p>确认收货成功页面</p></li><li><p>进行评论页面<br>（1）显示要评价的商品信息，商品当前的总评价数<br>（2）评价成功后，显示当前商品所有的评价信息    </p></li><li><p>登陆页面</p></li><li><p>注册页面</p></li></ol><hr><h4 id="需求分析后台-后台"><a href="#需求分析后台-后台" class="headerlink" title="需求分析后台-后台"></a>需求分析后台-后台</h4><ol><li>分类管理</li><li>分类属性管理</li><li>产品管理</li><li>产品属性设置</li><li>产品图片管理</li><li>用户管理</li><li>订单管理</li></ol><hr><h4 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h4><ol><li>创建数据库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS tmall_springboot;</span><br><span class="line">CREATE DATABASE tmall_springboot DEFAULT CHARACTER SET UTF0;</span><br></pre></td></tr></table></figure><ol start="2"><li>表设计</li></ol><table><thead><tr><th>表名</th><th align="center">中文含义</th><th align="right">介绍</th></tr></thead><tbody><tr><td>Category</td><td align="center">分类表</td><td align="right">存放分类信息，如女装，平板电视，沙发等</td></tr><tr><td>Property</td><td align="center">属性表</td><td align="right">放属性信息，如颜色，重量，品牌，厂商，型号等</td></tr><tr><td>Product</td><td align="center">产品表</td><td align="right">存放产品信息，如LED40EC平板电视机，海尔EC6005热水器</td></tr><tr><td>PropertyValue</td><td align="center">属性值表</td><td align="right">存放属性值信息，如重量是900g,颜色是粉红色</td></tr><tr><td>ProductImage</td><td align="center">产品图片表</td><td align="right">存放产品图片信息，如产品页显示的5个图片</td></tr><tr><td>Review</td><td align="center">评论表</td><td align="right">存放评论信息，如买回来的蜡烛很好用，么么哒</td></tr><tr><td>User</td><td align="center">用户表</td><td align="right">存放用户信息，如斩手狗，千手小粉红</td></tr><tr><td>Order</td><td align="center">订单表</td><td align="right">存放订单信息，包括邮寄地址，电话号码等信息</td></tr><tr><td>OrderItem</td><td align="center">订单项表</td><td align="right">存放订单项信息，包括购买产品种类，数量等</td></tr></tbody></table><ol start="3"><li>表关系</li></ol><table><thead><tr><th>一</th><th align="left">多</th></tr></thead><tbody><tr><td>Category-分类</td><td align="left">Product-产品</td></tr><tr><td>Category-分类</td><td align="left">Property-属性</td></tr><tr><td>Property-属性</td><td align="left">PropertyValue-属性值</td></tr><tr><td>Product-产品</td><td align="left">PropertyValue-属性值</td></tr><tr><td>Product-产品</td><td align="left">ProductImage-产品图片</td></tr><tr><td>Product-产品</td><td align="left">Review-评价</td></tr><tr><td>Product-产品</td><td align="left">OrderItem-订单项</td></tr><tr><td>User-用户</td><td align="left">Order-订单</td></tr><tr><td>User-用户</td><td align="left">OrderItem-订单项</td></tr><tr><td>Order-订单</td><td align="left">OrderItem-订单项</td></tr><tr><td>User-用户</td><td align="left">Review-评价</td></tr></tbody></table><ol start="4"><li>用户表</li></ol><p>salt是盐，用来和shiro结合的时候，加密用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">name varchar(255) DEFAULT NULL,</span><br><span class="line">password varchar(255) DEFAULT NULL,</span><br><span class="line">salt varchar(255) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">) ENGINE &#x3D; InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="5"><li>分类表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE category (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  name varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="6"><li>属性表<br>本表的外键cid，指向分类表的id字段</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE property (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  cid int(11) DEFAULT NULL,</span><br><span class="line">  name varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  CONSTRAINT fk_property_category FOREIGN KEY (cid) REFERENCES category(id)</span><br><span class="line">  ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="7"><li>产品表</li></ol><p>name: 产品名称<br>subTitle: 小标题<br>originalPrice: 原始价格<br>promotePrice: 优惠价格<br>stock: 库存<br>createDate: 创建日期</p><p>本表的外键cid，指向分类表的id字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">REATE TABLE product (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  name varchar(255) DEFAULT NULL,</span><br><span class="line">  subTitle varchar(255) DEFAULT NULL,</span><br><span class="line">  originalPrice float DEFAULT NULL,</span><br><span class="line">  promotePrice float DEFAULT NULL,</span><br><span class="line">  stock int(11) DEFAULT NULL,</span><br><span class="line">  cid int(11) DEFAULT NULL,</span><br><span class="line">  createDate datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  CONSTRAINT fk_product_category FOREIGN KEY (cid) REFERENCES category (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="8"><li>属性值表</li></ol><p>本表有两个外键<br>外键ptid，指向属性表的id字段<br>外键pid，指向产品表的id字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE propertyvalue (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  pid int(11) DEFAULT NULL,</span><br><span class="line">  ptid int(11) DEFAULT NULL,</span><br><span class="line">  value varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  CONSTRAINT fk_propertyvalue_property FOREIGN KEY (ptid) REFERENCES property (id),</span><br><span class="line">  CONSTRAINT fk_propertyvalue_product FOREIGN KEY (pid) REFERENCES product (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="9"><li>产品图片表</li></ol><p>type表示类型，产品图片分单个图片和详情图片两种</p><p>本表的外键pid，指向产品表的id字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productimage (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  pid int(11) DEFAULT NULL,</span><br><span class="line">  type varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  CONSTRAINT fk_productimage_product FOREIGN KEY (pid) REFERENCES product (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="10"><li>评价表</li></ol><p>外键pid，指向产品表的id字段<br>外键uid，指向用户表的id字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE review (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  content varchar(4000) DEFAULT NULL,</span><br><span class="line">  uid int(11) DEFAULT NULL,</span><br><span class="line">  pid int(11) DEFAULT NULL,</span><br><span class="line">  createDate datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  CONSTRAINT fk_review_product FOREIGN KEY (pid) REFERENCES product (id),</span><br><span class="line">    CONSTRAINT fk_review_user FOREIGN KEY (uid) REFERENCES user (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="11"><li>订单表</li></ol><p>orderCode： 订单号<br>address:收货地址<br>post: 邮编<br>receiver: 收货人信息<br>mobile: 手机号码<br>userMessage: 用户备注信息<br>createDate: 订单创建日期<br>payDate: 支付日期<br>deliveryDate: 发货日期<br>confirmDate：确认收货日期<br>status: 订单状态<br>外键uid，指向用户表id字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE order_ (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  orderCode varchar(255) DEFAULT NULL,</span><br><span class="line">  address varchar(255) DEFAULT NULL,</span><br><span class="line">  post varchar(255) DEFAULT NULL,</span><br><span class="line">  receiver varchar(255) DEFAULT NULL,</span><br><span class="line">  mobile varchar(255) DEFAULT NULL,</span><br><span class="line">  userMessage varchar(255) DEFAULT NULL,</span><br><span class="line">  createDate datetime DEFAULT NULL,</span><br><span class="line">  payDate datetime DEFAULT NULL,</span><br><span class="line">  deliveryDate datetime DEFAULT NULL,</span><br><span class="line">  confirmDate datetime DEFAULT NULL,</span><br><span class="line">  uid int(11) DEFAULT NULL,</span><br><span class="line">  status varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  CONSTRAINT fk_order_user FOREIGN KEY (uid) REFERENCES user (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="12"><li>订单项表</li></ol><p>这个表是外键最多的一个表<br>外键pid，指向产品表id字段<br>外键oid，指向订单表id字段<br>外键uid，指向用户表id字段<br>number字段表示购买数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE orderitem (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  pid int(11) DEFAULT NULL,</span><br><span class="line">  oid int(11) DEFAULT NULL,</span><br><span class="line">  uid int(11) DEFAULT NULL,</span><br><span class="line">  number int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  CONSTRAINT fk_orderitem_user FOREIGN KEY (uid) REFERENCES user (id),</span><br><span class="line">  CONSTRAINT fk_orderitem_product FOREIGN KEY (pid) REFERENCES product (id),</span><br><span class="line">  CONSTRAINT fk_orderitem_order FOREIGN KEY (oid) REFERENCES order_ (id)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      spring boot开发天猫
    
    </summary>
    
    
      <category term="项目开发" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="工程" scheme="http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>刷题-acwing</title>
    <link href="http://yoursite.com/2019/12/23/acwing/"/>
    <id>http://yoursite.com/2019/12/23/acwing/</id>
    <published>2019-12-23T07:48:59.337Z</published>
    <updated>2020-01-06T06:51:25.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="acwing"><a href="#acwing" class="headerlink" title="acwing"></a>acwing</h2><hr><h3 id="（1）找到数组中重复的数字"><a href="#（1）找到数组中重复的数字" class="headerlink" title="（1）找到数组中重复的数字"></a>（1）找到数组中重复的数字</h3><p>给定一个长度为 n 的整数数组 nums，数组中所有的数字都在 0∼n−1 的范围内。</p><p>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。</p><p>请找出数组中任意一个重复的数字。</p><p>注意：如果某些数字不在 0∼n−1 的范围内，或数组中不包含重复数字，则返回 -1；</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。</p><p>返回 2 或 3。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先判断数组所有的数字不小于0或者大于数组长度，然后循环数组，遍历每个数组元素，如果nums[i]不等于i,就将nums[i]和i上的数字交换，交换前判断是否和i上的数字相等，如果相等就返回，如果不相等就继续交换。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> || nums[i] &gt; len - <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                   nums[i] = nums[tmp];</span><br><span class="line">                   nums[tmp] = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="（2）不修改数组找出重复的数字"><a href="#（2）不修改数组找出重复的数字" class="headerlink" title="（2）不修改数组找出重复的数字"></a>（2）不修改数组找出重复的数字</h3><p>给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。</p><p>请找出数组中任意一个重复的数，但不能修改输入的数组。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><p>给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。</p><p>返回 2 或 3。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>采用分治法，将每个数的取值的区间[1, n]划分成[1, n/2]和[n/2+1, n]两个子区间，然后分别统计两个区间中数的个数。注意<strong>这里的区间是指 数的取值范围，而不是 数组下标。</strong> 然后取数的个数大于区间长度的一半，最后返回r.</p><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> s= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x &lt;= mid &amp;&amp; x &gt;= l) s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="（3）二维数组中的查找"><a href="#（3）二维数组中的查找" class="headerlink" title="（3）二维数组中的查找"></a>（3）二维数组中的查找</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入数组：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>]，</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>]，</span><br><span class="line">  [<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>]，</span><br><span class="line">  [<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">如果输入查找数值为<span class="number">7</span>，则返回<span class="keyword">true</span>，</span><br><span class="line"></span><br><span class="line">如果输入查找数值为<span class="number">5</span>，则返回<span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>数组从上到下，从左到右是增大的，所以先取右上角数字x，如果和target相等，则返回，如果小于target，则排除这一行，枚举的点横坐标加一。如果大于target，则排除这一列，枚举的纵坐标减一。如果没有，返回false；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchArray</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array!=<span class="keyword">null</span> &amp;&amp; array.length &gt; <span class="number">0</span> &amp;&amp; array[<span class="number">0</span>].length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[row][col]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[row][col]) col--;</span><br><span class="line">             <span class="keyword">else</span> row++;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="（4）从尾到头打印链表"><a href="#（4）从尾到头打印链表" class="headerlink" title="（4）从尾到头打印链表"></a>（4）从尾到头打印链表</h3><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p><p>返回的结果用数组存储。</p><h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">返回：[<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>先将链表存入栈，然后将栈中元素放入链表，返回。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] printListReversingly(ListNode head) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack.push(heda.val);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    arr.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.size()];<span class="comment">//因为不知道数组的大小，所以先存入arraylist，然后定义数组，存入其中</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.size();i++)&#123;</span><br><span class="line">    arr1[i] = arr.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）重建二叉树"><a href="#（5）重建二叉树" class="headerlink" title="（5）重建二叉树"></a>（5）重建二叉树</h3><p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p><p><strong>注意</strong>:</p><ul><li>二叉树中每个节点的值都互不相同；</li><li>输入的前序遍历和中序遍历一定合法；</li></ul><h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定：</span><br><span class="line">前序遍历是：[<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span>]</span><br><span class="line">中序遍历是：[<span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">返回：[<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>]</span><br><span class="line">返回的二叉树如下所示：</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li><p>先利用前序遍历找根节点：前序遍历的第一个数，就是根节点的值；</p></li><li><p>在中序遍历中找到根节点的位置 kk，则 kk 左边是左子树的中序遍历，右边是右子树的中序遍历；</p></li><li><p>假设左子树的中序遍历的长度是 ll，则在前序遍历中，根节点后面的 ll 个数，是左子树的前序遍历，剩下的数是右子树的前序遍历；</p></li><li><p>有了左右子树的前序遍历和中序遍历，我们可以先递归创建出左右子树，然后再创建根节点；</p></li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">      TreeNode root = re(preorder,<span class="number">0</span>,preorder.length - <span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">re</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span> startpre,<span class="keyword">int</span> endpre,<span class="keyword">int</span>[] in,<span class="keyword">int</span> startin,<span class="keyword">int</span> endin)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(startpre &gt; endpre || startin &gt; endin)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      TreeNode root = <span class="keyword">new</span> TreeNode(pre[startpre]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = startin; i &lt;= endin; i++ )&#123;</span><br><span class="line">          <span class="keyword">if</span>(in[i] == pre[startpre])&#123;</span><br><span class="line">              root.left = re(pre,startpre+<span class="number">1</span>,startpre+i-startin,in,startin,i-<span class="number">1</span>);</span><br><span class="line">              root.right = re(pre,startpre+i-startin+<span class="number">1</span>,endpre,in,i+<span class="number">1</span>,endin);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-二叉树的下个节点"><a href="#6-二叉树的下个节点" class="headerlink" title="(6)二叉树的下个节点"></a>(6)二叉树的下个节点</h3><p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。</p><p><strong>注意：</strong></p><ul><li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li><li>二叉树一定不为空，且给定的节点一定不是空节点；</li></ul><h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假定二叉树是：[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>]， 给出的是值等于<span class="number">2</span>的节点。</span><br><span class="line"></span><br><span class="line">则应返回值等于<span class="number">3</span>的节点。</span><br><span class="line"></span><br><span class="line">解释：该二叉树的结构如下，<span class="number">2</span>的后继节点是<span class="number">3</span>。</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>分两种情况：</p><p>（1）给定节点有右节点，则为右节点的左儿子</p><p>（2）给定节点没有右节点，则找节点的父亲节点，如果为父亲节点的左儿子，则其父亲节点就是后继节点。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">          p = p.right;</span><br><span class="line">          <span class="keyword">while</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">              p = p.left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(p.father !=<span class="keyword">null</span> &amp;&amp; p == p.father.right) p = p.father;</span><br><span class="line">      <span class="keyword">return</span> p.father;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="7-用两个栈实现队列"><a href="#7-用两个栈实现队列" class="headerlink" title="(7)用两个栈实现队列"></a>(7)用两个栈实现队列</h3><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);</span><br><span class="line">queue.peek();  <span class="comment">// returns 1</span></span><br><span class="line">queue.pop();   <span class="comment">// returns 1</span></span><br><span class="line">queue.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>pop是将元素放入第二个栈中，然后取出，返回。peek是将元素取出即可。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Stack&lt;Integer&gt; stck = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; cache = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stck.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">if</span>(cache.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stck.empty())&#123;</span><br><span class="line">            a = stck.peek();</span><br><span class="line">            stck.pop();</span><br><span class="line">            cache.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = cache.peek();</span><br><span class="line">        cache.pop();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">if</span>(cache.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stck.empty())&#123;</span><br><span class="line">            b = stck.peek();</span><br><span class="line">            stck.pop();</span><br><span class="line">            cache.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b = cache.peek();</span><br><span class="line">               <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stck.empty() &amp;&amp; cache.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="8-斐波那且数列"><a href="#8-斐波那且数列" class="headerlink" title="(8)斐波那且数列"></a>(8)斐波那且数列</h3><p>输入一个整数 nn ，求斐波那契数列的第 nn 项。</p><p>假定从0开始，第0项为0。(nn&lt;=39)</p><h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入整数 n=<span class="number">5</span> </span><br><span class="line"></span><br><span class="line">返回 <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>用两个变量滚动式得往后计算，aa 表示第 n−1n−1 项，bb 表示第 nn 项。<br>则令 c=a+bc=a+b 表示第 n+1n+1 项，然后让 a,ba,b 顺次往后移一位。</p><p>时间复杂度分析<br>总共需要计算 nn 次，所以时间复杂度是 O(n)O(n) 。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">             c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            n --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="（9）-旋转数组的最小数字"><a href="#（9）-旋转数组的最小数字" class="headerlink" title="（9） 旋转数组的最小数字"></a>（9） 旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个升序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>数组可能包含重复项。</p><p><strong>注意</strong>：数组内所含元素非负，若数组大小为0，请返回-1。</p><h4 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums=[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>二分) O(n)O(n)<br>为了便于分析，我们先将数组中的数画在二维坐标系中，横坐标表示数组下标，纵坐标表示数值，如下所示：</p><p>图中水平的实线段表示相同元素。</p><img src="https://www.acwing.com/media/article/image/2019/01/06/1_9f7a5ff011-2.png" alt="avatar" style="zoom:80%;"><p>我们发现除了最后水平的一段（黑色水平那段）之外，其余部分满足二分性质：竖直虚线左边的数满足 nums[i]≥nums[0]nums[i]≥nums[0]；而竖直虚线右边的数不满足这个条件。<br>分界点就是整个数组的最小值。</p><p>所以我们先将最后水平的一段删除即可。</p><p>另外，不要忘记处理数组完全单调的特殊情况：</p><p>当我们删除最后水平的一段之后，如果剩下的最后一个数大于等于第一个数，则说明数组完全单调。<br>时间复杂度分析<br>二分的时间复杂度是 O(logn)O(logn)，删除最后水平一段的时间复杂度最坏是 O(n)O(n)，所以总时间复杂度是 O(n)O(n)。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; nums[n] == nums[<span class="number">0</span>]) n--;</span><br><span class="line">       <span class="keyword">if</span> (nums[n] &gt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line">       <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">           <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) r = mid;</span><br><span class="line">           <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums[r];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="（10）矩阵中的路径"><a href="#（10）矩阵中的路径" class="headerlink" title="（10）矩阵中的路径"></a>（10）矩阵中的路径</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</p><p>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。</p><p>如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。</p><p>注意：</p><p>输入的路径不为空；<br>所有出现的字符均为大写英文字母；</p><p>样例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">matrix=</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],</span><br><span class="line">  [<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],</span><br><span class="line">  [<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">str=<span class="string">"BCCE"</span> , <span class="keyword">return</span> <span class="string">"true"</span> </span><br><span class="line"></span><br><span class="line">str=<span class="string">"ASAE"</span> , <span class="keyword">return</span> <span class="string">"false"</span></span><br></pre></td></tr></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>采用回溯法，我们先枚举单词的起点，然后依次枚举单词的每个字母。<br>过程中需要将已经使用过的字母改成一个特殊字母，以避免重复使用字符。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[][] matrix, String str)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.length; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(dfs(matrix,str,<span class="number">0</span>,i,j))</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] matrix,String str,<span class="keyword">int</span> u,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix[x][y] != str.charAt(u)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(u == str.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">       <span class="keyword">char</span> t = matrix[x][y];</span><br><span class="line">       matrix[x][y] = <span class="string">'*'</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">           <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; matrix.length &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(dfs(matrix,str,u + <span class="number">1</span>,a,b)) <span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       matrix[x][y] = t;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="（11）机器人的运动范围"><a href="#（11）机器人的运动范围" class="headerlink" title="（11）机器人的运动范围"></a>（11）机器人的运动范围</h3><p>地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。</p><p>一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。</p><p>但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p><p>请问该机器人能够达到多少个格子？</p><p>样例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：k=<span class="number">7</span>, m=<span class="number">4</span>, n=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">样例<span class="number">2</span></span><br><span class="line">输入：k=<span class="number">18</span>, m=<span class="number">40</span>, n=<span class="number">40</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1484</span></span><br><span class="line"></span><br><span class="line">解释：当k为<span class="number">18</span>时，机器人能够进入方格（<span class="number">35</span>,<span class="number">37</span>），因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">7</span> = <span class="number">18</span>。</span><br><span class="line">      但是，它不能进入方格（<span class="number">35</span>,<span class="number">38</span>），因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">8</span> = <span class="number">19</span>。</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>&lt;=m&lt;=<span class="number">50</span></span><br><span class="line"><span class="number">0</span>&lt;=n&lt;=<span class="number">50</span></span><br><span class="line"><span class="number">0</span>&lt;=k&lt;=<span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>建一个标记数组，标记每个位置是否访问过，新建一个类，存入横纵坐标，首先放入（0，0）位置到linkedlist，然后判断其临近的四个位置上的，是否满足在界限内，没访问过，位数上的数字之和小于给定的值，如果满足，将其放入队列，总数加一。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(rows &lt;= <span class="number">0</span> || cols &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">     LinkedList&lt;Pair&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     list.add(<span class="keyword">new</span> Pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">     vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span>[] dx = &#123; -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">     <span class="keyword">int</span>[] dy = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">     <span class="keyword">while</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">         Pair pair = list.remove();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">             <span class="keyword">int</span> xx = pair.x + dx[i];</span><br><span class="line">             <span class="keyword">int</span> yy = pair.y + dy[i];</span><br><span class="line">             <span class="keyword">if</span>(xx &gt;=<span class="number">0</span> &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; xx &lt;rows &amp;&amp; yy &lt; cols &amp;&amp; !vis[xx][yy])&#123;</span><br><span class="line">             <span class="keyword">if</span>((xx/<span class="number">10</span> + xx%<span class="number">10</span> + yy/<span class="number">10</span> + yy%<span class="number">10</span>) &lt;= threshold)&#123;</span><br><span class="line">                 list.add(<span class="keyword">new</span> Pair(xx,yy));</span><br><span class="line">                 res++;</span><br><span class="line">             &#125;</span><br><span class="line">             vis[xx][yy] = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-剪绳子"><a href="#12-剪绳子" class="headerlink" title="(12) 剪绳子"></a>(12) 剪绳子</h3><p>给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。</p><p>每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？</p><p>例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">输入：<span class="number">8</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>(数学) O(n)O(n)<br>这道题目是数学中一个很经典的问题。<br>下面我们给出证明：</p><p>首先把一个正整数 NN 拆分成若干正整数只有有限种拆法，所以存在最大乘积。<br>假设 N=n1+n2+…+nkN=n1+n2+…+nk，并且 n1×n2×…×nkn1×n2×…×nk 是最大乘积。</p><p>显然1不会出现在其中；<br>如果对于某个 ii 有 ni≥5ni≥5，那么把 nini 拆分成 3+(ni−3)3+(ni−3)，我们有 3(ni−3)=3ni−9&gt;ni3(ni−3)=3ni−9&gt;ni；<br>如果 ni=4ni=4，拆成 2+22+2乘积不变，所以不妨假设没有4；<br>如果有三个以上的2，那么 3×3&gt;2×2×23×3&gt;2×2×2，所以替换成3乘积更大；<br>综上，选用尽量多的3，直到剩下2或者4时，用2。</p><p>时间复杂度分析：当 nn 比较大时，nn 会被拆分成 ⌈n/3⌉⌈n/3⌉ 个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 O(n)O(n)。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">3</span>)  <span class="keyword">return</span> (length -<span class="number">1</span>) * <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length % <span class="number">3</span> == <span class="number">1</span>)  &#123;length = length -<span class="number">4</span>;res = <span class="number">4</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(length % <span class="number">3</span> == <span class="number">2</span>)  &#123;length = length -<span class="number">2</span>;res = <span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        res = res *<span class="number">3</span>;</span><br><span class="line">        length = length -<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="（13）二进制中1的个数"><a href="#（13）二进制中1的个数" class="headerlink" title="（13）二进制中1的个数"></a>（13）二进制中1的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入一个<span class="number">32</span>位整数，输出该数二进制表示中<span class="number">1</span>的个数。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">负数在计算机中用其绝对值的补码来表示。</span><br><span class="line">样例<span class="number">1</span></span><br><span class="line">输入：<span class="number">9</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">9</span>的二进制表示是<span class="number">1001</span>，一共有<span class="number">2</span>个<span class="number">1</span>。</span><br><span class="line">样例<span class="number">2</span></span><br><span class="line">输入：-<span class="number">2</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：-<span class="number">2</span>在计算机里会被表示成<span class="number">11111111111111111111111111111110</span>，</span><br><span class="line">      一共有<span class="number">31</span>个<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>（1）是将1左移，与n做&amp;操作，如果不等于0，则加一。知道将1左移变为了0；<br>（2）n与n-1做与操作，每次减去最右边的1，知道变为了0；</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; flag) != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">           n = n &amp; (n -<span class="number">1</span>);</span><br><span class="line">           res++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### （14） 数值的整数次方</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">实现函数<span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span>，求base的 exponent次方。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">不得使用库函数，同时不需要考虑大数问题。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注意：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">不会出现底数和指数同为0的情况</span></span><br><span class="line"><span class="function">样例1</span></span><br><span class="line"><span class="function">输入：10 ，2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输出：100</span></span><br><span class="line"><span class="function">样例2</span></span><br><span class="line"><span class="function">输入：10 ，-2  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输出：0.01</span></span><br></pre></td></tr></table></figure><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>先直接取exponent的绝对值，算出次方，然后判断exponent的正负，为负取倒数</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Math.abs(exponent);i++ )</span><br><span class="line">           res *=base;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">          res = <span class="number">1</span>/res;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>###（15） 在O(1)时间删除链表结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定单向链表的一个节点指针，定义一个函数在O(<span class="number">1</span>)时间删除该结点。</span><br><span class="line"></span><br><span class="line">假设链表一定存在，并且该节点一定不是尾节点。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入：链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">6</span>-&gt;<span class="number">8</span></span><br><span class="line">      删掉节点：第<span class="number">2</span>个节点即<span class="number">6</span>（头节点为第<span class="number">0</span>个节点）</span><br><span class="line"></span><br><span class="line">输出：新链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>node的值去下一个的值，node的next取node的next的next</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">      node.val = node.next.val;</span><br><span class="line">      node.next = node.next.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="16-删除链表中重复的节点"><a href="#16-删除链表中重复的节点" class="headerlink" title="(16)删除链表中重复的节点"></a>(16)删除链表中重复的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。</span><br><span class="line"></span><br><span class="line">样例<span class="number">1</span></span><br><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br><span class="line">样例<span class="number">2</span></span><br><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>创建虚拟头节点，p指针指向虚拟头节点，q指针指向p的下个，然后遍历q.next，删掉所有相同的，如果没有，则循环p。</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">      ListNode dmmy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      dmmy.next = head;</span><br><span class="line">      ListNode p = dmmy;</span><br><span class="line">      <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">          ListNode q = p.next;</span><br><span class="line">          <span class="keyword">while</span>(q !=<span class="keyword">null</span> &amp;&amp; q.val == p.next.val) q = q.next;</span><br><span class="line">          <span class="keyword">if</span>(p.next.next == q)p = p.next;</span><br><span class="line">          <span class="keyword">else</span> p.next = q;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dmmy.next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      acwing题目
    
    </summary>
    
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="acwing" scheme="http://yoursite.com/tags/acwing/"/>
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>No1</title>
    <link href="http://yoursite.com/2019/12/23/No1-1/"/>
    <id>http://yoursite.com/2019/12/23/No1-1/</id>
    <published>2019-12-23T02:34:06.302Z</published>
    <updated>2019-12-23T05:35:51.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发文模板"><a href="#发文模板" class="headerlink" title="发文模板"></a>发文模板</h2><h3 id="增加description，可现实“阅读全文”"><a href="#增加description，可现实“阅读全文”" class="headerlink" title="增加description，可现实“阅读全文”"></a>增加description，可现实“阅读全文”</h3>]]></content>
    
    <summary type="html">
    
      我的第一篇文章
    
    </summary>
    
    
      <category term="成长" scheme="http://yoursite.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="琐碎" scheme="http://yoursite.com/tags/%E7%90%90%E7%A2%8E/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/12/23/hello-world/"/>
    <id>http://yoursite.com/2019/12/23/hello-world/</id>
    <published>2019-12-23T01:25:34.777Z</published>
    <updated>2019-12-23T06:36:36.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
    
    </summary>
    
    
      <category term="成长" scheme="http://yoursite.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="琐碎" scheme="http://yoursite.com/tags/%E7%90%90%E7%A2%8E/"/>
    
  </entry>
  
</feed>
